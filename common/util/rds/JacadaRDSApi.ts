/**
 * Raw Data Service API
 * Raw data service (aka rds) API's documentation
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require('request');
//import http = require('http');
import * as http from 'http';
import Promise = require('bluebird');

let defaultBasePath = 'https://gointeract.io/rds';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class AggregationCreateResponse {
  'aggregationId': string;
}

export class AggregationDTO {
  'creationTime': number;
  'description': string;
  'id': string;
  'mapFunction': string;
  'name': string;
  'query': string;
  'reduceFunction': string;
}

export class AggregationResponse {
  'id': string;
  'result': Array<any>;
}

export class BatchResponse {
  'batchId': string;
}

export class CustomerDTO {
  'additionalData': { [key: string]: string; };
  'address': string;
  'company': string;
  'email': string;
  'id': string;
  'name': string;
  'phone': string;
}

export class EventDTO {
  'additionalData': { [key: string]: string; };
  'description': string;
  'pageId': string;
  'timestamp': number;
  'type': string;
}

export class FieldDTO {
  'field': string;
  'op': string;
  'type': string;
  'value': string;
}

export class PageDTO {
  'additionalData': { [key: string]: string; };
  'fullUrl': string;
  'id': string;
  'name': string;
  'timeSpent': number;
  'timestamp': number;
}

export class QueryFieldsDTO {
  'fields': Array<FieldDTO>;
}

export class TenantInfoDTO {
  'headers': { [key: string]: string; };
  'notifyUrl': string;
}

export class TransactionDTO {
  'additionalData': { [key: string]: string; };
  'categoryId': string;
  'customerId': string;
  'endTimestamp': number;
  'events': Array<EventDTO>;
  'externalSystemId': string;
  'id': string;
  'ipAddress': string;
  'name': string;
  'pages': Array<PageDTO>;
  'source': string;
  'startTimestamp': number;
  'userAgent': string;
  'variables': Array<VariableDTO>;
}

export class Variable {
  'additionalData': { [key: string]: string; };
  'defaultValue': string;
  'id': string;
  'lastValue': string;
  'name': string;
  'values': Array<VariableValue>;
}

export class VariableDTO {
  'additionalData': { [key: string]: string; };
  'defaultValue': string;
  'id': string;
  'lastValue': string;
  'name': string;
  'values': Array<VariableValue>;
}

export class VariableValue {
  'element': string;
  'timestamp': number;
  'value': string;
}


export interface Authentication {
  /**
   * Apply authentication settings to header and query params.
   */
  applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
  public username: string;
  public password: string;
  applyToRequest(requestOptions: request.Options): void {
    requestOptions.auth = {
      username: this.username, password: this.password
    }
  }
}

export class ApiKeyAuth implements Authentication {
  public apiKey: string;

  constructor(private location: string, private paramName: string) {
  }

  applyToRequest(requestOptions: request.Options): void {
    if (this.location == "query") {
      (<any>requestOptions.qs)[this.paramName] = this.apiKey;
    } else if (this.location == "header" && requestOptions && requestOptions.headers) {
      requestOptions.headers[this.paramName] = this.apiKey;
    }
  }
}

export class OAuth implements Authentication {
  public accessToken: string;

  applyToRequest(requestOptions: request.Options): void {
    if (requestOptions && requestOptions.headers) {
      requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
  }
}

export class VoidAuth implements Authentication {
  public username: string;
  public password: string;
  applyToRequest(_: request.Options): void {
    // Do nothing
  }
}

export enum AggregationcontrollerApiApiKeys {
}

export class AggregationcontrollerApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders : any = {};
  protected _useQuerystring : boolean = false;

  protected authentications = {
    'default': <Authentication>new VoidAuth(),
  }

  constructor(basePath?: string);
  constructor(basePathOrUsername: string, password?: string, basePath?: string) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: AggregationcontrollerApiApiKeys, value: string) {
    this.authentications[AggregationcontrollerApiApiKeys[key]].apiKey = value;
  }
  /**
   * Aggregates raw data by given query.   If the query is invalid HTTP code 406 is returned
   * @summary Aggregates raw data
   * @param applicationKey RDS application key
   * @param aggregationDTO AggregationDTO includes the Aggregation query.   The aggregation query json must be escaped.   See https://www.freeformatter.com/json-escape.html for online json escaping  Illegal keywords: &#39;$where&#39;, &#39;$lookup&#39;, &#39;$out&#39;, &#39;$collStats&#39;, &#39;$indexStats&#39;, &#39;startTimestamp&#39; and &#39;endTimestamp&#39; in $match stage
   * @param tenantId Tenant Id
   * @param env Tenant environment name (Interact multi-emvironment)
   */
  public aggregate (applicationKey: string, aggregationDTO: AggregationDTO, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: AggregationCreateResponse;  }> {
    const localVarPath = this.basePath + '/aggregation';
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling aggregate.');
    }

    // verify required parameter 'aggregationDTO' is not null or undefined
    if (aggregationDTO === null || aggregationDTO === undefined) {
      throw new Error('Required parameter aggregationDTO was null or undefined when calling aggregate.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling aggregate.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'POST',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: aggregationDTO,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: AggregationCreateResponse;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Returns aggregated data by given query.   If the query is invalid HTTP code 406 is returned
   * @summary Retrieves aggregated data
   * @param applicationKey RDS application key
   * @param query Aggregation query.  The aggregation query json must be escaped.   See https://www.freeformatter.com/json-escape.html for online json escaping  Illegal keywords: &#39;$where&#39;, &#39;$lookup&#39;, &#39;$out&#39;, &#39;$collStats&#39;, &#39;$indexStats&#39;
   * @param aggregationId Aggregation definition id
   * @param tenantId Tenant Id
   * @param env Tenant environment name (Interact multi-emvironment)
   */
  public aggregationRetrieve (applicationKey: string, query: ModelString, aggregationId: string, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: Array<any>;  }> {
    const localVarPath = this.basePath + '/aggregation/results/{aggregationId}'
      .replace('{' + 'aggregationId' + '}', String(aggregationId));
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling aggregationRetrieve.');
    }

    // verify required parameter 'query' is not null or undefined
    if (query === null || query === undefined) {
      throw new Error('Required parameter query was null or undefined when calling aggregationRetrieve.');
    }

    // verify required parameter 'aggregationId' is not null or undefined
    if (aggregationId === null || aggregationId === undefined) {
      throw new Error('Required parameter aggregationId was null or undefined when calling aggregationRetrieve.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling aggregationRetrieve.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'POST',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: query,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<any>;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * For testing the aggregation query before calling the aggregate API.  Will run the query on the past 4 hours and will return the results of the aggregation.  If the query is invalid HTTP code 406 is returned
   * @summary Tests aggregation query of raw data
   * @param applicationKey RDS application key
   * @param query Aggregation test query.  The aggregation query json must be escaped.   See https://www.freeformatter.com/json-escape.html for online json escaping  Illegal keywords: &#39;$where&#39;, &#39;$lookup&#39;, &#39;$out&#39;, &#39;$collStats&#39;, &#39;$indexStats&#39;, &#39;startTimestamp&#39; and &#39;endTimestamp&#39; in $match stage
   * @param tenantId Tenant Id
   * @param env Tenant environment name (Interact multi-emvironment)
   */
  public aggregationTest (applicationKey: string, query: ModelString, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: AggregationResponse;  }> {
    const localVarPath = this.basePath + '/aggregation/test';
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling aggregationTest.');
    }

    // verify required parameter 'query' is not null or undefined
    if (query === null || query === undefined) {
      throw new Error('Required parameter query was null or undefined when calling aggregationTest.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling aggregationTest.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'POST',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: query,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: AggregationResponse;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Deletes aggregation by id, if the the aggregation not exists HTTP code 404 returned
   * @summary Deletes a specific aggregation in RDS
   * @param applicationKey
   * @param aggregationId The aggregation ID
   * @param tenantId
   * @param env
   */
  public deleteAggregation (applicationKey: string, aggregationId: string, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
    const localVarPath = this.basePath + '/aggregation/{aggregationId}'
      .replace('{' + 'aggregationId' + '}', String(aggregationId));
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling deleteAggregation.');
    }

    // verify required parameter 'aggregationId' is not null or undefined
    if (aggregationId === null || aggregationId === undefined) {
      throw new Error('Required parameter aggregationId was null or undefined when calling deleteAggregation.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling deleteAggregation.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'DELETE',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Returns aggregated data by given query.
   * @summary Retrieves aggregated data by find query
   * @param applicationKey RDS application key
   * @param queryFieldsDTO Fields to use in the find query.
   * @param aggregationId Aggregation definition id
   * @param tenantId Tenant Id
   * @param env Tenant environment name (Interact multi-emvironment)
   */
  public findQueryRetrieve (applicationKey: string, queryFieldsDTO: QueryFieldsDTO, aggregationId: string, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: Array<any>;  }> {
    const localVarPath = this.basePath + '/aggregation/results/simple/{aggregationId}'
      .replace('{' + 'aggregationId' + '}', String(aggregationId));
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling findQueryRetrieve.');
    }

    // verify required parameter 'queryFieldsDTO' is not null or undefined
    if (queryFieldsDTO === null || queryFieldsDTO === undefined) {
      throw new Error('Required parameter queryFieldsDTO was null or undefined when calling findQueryRetrieve.');
    }

    // verify required parameter 'aggregationId' is not null or undefined
    if (aggregationId === null || aggregationId === undefined) {
      throw new Error('Required parameter aggregationId was null or undefined when calling findQueryRetrieve.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling findQueryRetrieve.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'POST',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: queryFieldsDTO,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<any>;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Get list of aggregations created for tenant
   * @summary Gets list of aggregations
   * @param applicationKey
   * @param tenantId
   * @param env
   */
  public getAggregations (applicationKey: string, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: Array<AggregationDTO>;  }> {
    const localVarPath = this.basePath + '/aggregation';
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling getAggregations.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling getAggregations.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'GET',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<AggregationDTO>;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Updates aggregation by id, if the the aggregation not exists HTTP code 404 returned
   * @summary Updates a specific aggregation in RDS
   * @param applicationKey
   * @param aggregationId The aggregation ID
   * @param aggregationDTO AggregationDTO includes the Aggregation query.   The aggregation query json must be escaped.   See https://www.freeformatter.com/json-escape.html for online json escaping  Illegal keywords: &#39;$where&#39;, &#39;$lookup&#39;, &#39;$out&#39;, &#39;$collStats&#39;, &#39;$indexStats&#39;, &#39;startTimestamp&#39; and &#39;endTimestamp&#39; in $match stage
   * @param tenantId
   * @param env
   */
  public updateAggregation (applicationKey: string, aggregationId: string, aggregationDTO: AggregationDTO, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
    const localVarPath = this.basePath + '/aggregation/{aggregationId}'
      .replace('{' + 'aggregationId' + '}', String(aggregationId));
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling updateAggregation.');
    }

    // verify required parameter 'aggregationId' is not null or undefined
    if (aggregationId === null || aggregationId === undefined) {
      throw new Error('Required parameter aggregationId was null or undefined when calling updateAggregation.');
    }

    // verify required parameter 'aggregationDTO' is not null or undefined
    if (aggregationDTO === null || aggregationDTO === undefined) {
      throw new Error('Required parameter aggregationDTO was null or undefined when calling updateAggregation.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling updateAggregation.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'PUT',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: aggregationDTO,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum CustomercontrollerApiApiKeys {
}

export class CustomercontrollerApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders : any = {};
  protected _useQuerystring : boolean = false;

  protected authentications = {
    'default': <Authentication>new VoidAuth(),
  }

  constructor(basePath?: string);
  constructor(basePathOrUsername: string, password?: string, basePath?: string) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: CustomercontrollerApiApiKeys, value: string) {
    this.authentications[CustomercontrollerApiApiKeys[key]].apiKey = value;
  }
  /**
   * Creates the customer in RDS from the CustomerDTO in the body and return HTTP code 201 (created)
   * @summary Creates customer in RDS
   * @param applicationKey
   * @param customerDto The customer body
   * @param tenantId
   * @param env
   */
  public createCustomer (applicationKey: string, customerDto: CustomerDTO, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: CustomerDTO;  }> {
    const localVarPath = this.basePath + '/customers';
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling createCustomer.');
    }

    // verify required parameter 'customerDto' is not null or undefined
    if (customerDto === null || customerDto === undefined) {
      throw new Error('Required parameter customerDto was null or undefined when calling createCustomer.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling createCustomer.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'POST',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: customerDto,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CustomerDTO;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Deletes customer by id, if the the customer not exists HTTP code 404 returned
   * @summary Deletes a customer in RDS
   * @param applicationKey
   * @param customerId The customer ID
   * @param tenantId
   * @param env
   */
  public deleteCustomer (applicationKey: string, customerId: string, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
    const localVarPath = this.basePath + '/customers/{customerId}'
      .replace('{' + 'customerId' + '}', String(customerId));
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling deleteCustomer.');
    }

    // verify required parameter 'customerId' is not null or undefined
    if (customerId === null || customerId === undefined) {
      throw new Error('Required parameter customerId was null or undefined when calling deleteCustomer.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling deleteCustomer.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'DELETE',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Reads the customer from RDS by customer id, if the customer not exists in RDS, HTTP error 404 returned
   * @summary Gets specific customer from RDS by customer id
   * @param applicationKey
   * @param customerId The customer ID
   * @param tenantId
   * @param env
   */
  public readCustomer (applicationKey: string, customerId: string, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: CustomerDTO;  }> {
    const localVarPath = this.basePath + '/customers/{customerId}'
      .replace('{' + 'customerId' + '}', String(customerId));
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling readCustomer.');
    }

    // verify required parameter 'customerId' is not null or undefined
    if (customerId === null || customerId === undefined) {
      throw new Error('Required parameter customerId was null or undefined when calling readCustomer.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling readCustomer.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'GET',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CustomerDTO;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Using customer id and CustomerDTO will update the spcific customer and return HTTP code 200 if success or if the customer not found HTTP code 404
   * @summary Updates customer in RDS
   * @param applicationKey
   * @param customerDto The customer body
   * @param customerId The customer ID
   * @param tenantId
   * @param env
   */
  public updateCustomer (applicationKey: string, customerDto: string, customerId: string, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: CustomerDTO;  }> {
    const localVarPath = this.basePath + '/customers/{customerId}'
      .replace('{' + 'customerId' + '}', String(customerId));
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling updateCustomer.');
    }

    // verify required parameter 'customerDto' is not null or undefined
    if (customerDto === null || customerDto === undefined) {
      throw new Error('Required parameter customerDto was null or undefined when calling updateCustomer.');
    }

    // verify required parameter 'customerId' is not null or undefined
    if (customerId === null || customerId === undefined) {
      throw new Error('Required parameter customerId was null or undefined when calling updateCustomer.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling updateCustomer.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'PUT',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: customerDto,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: CustomerDTO;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum TenantinfocontrollerApiApiKeys {
}

export class TenantinfocontrollerApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders : any = {};
  protected _useQuerystring : boolean = false;

  protected authentications = {
    'default': <Authentication>new VoidAuth(),
  }

  constructor(basePath?: string);
  constructor(basePathOrUsername: string, password?: string, basePath?: string) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: TenantinfocontrollerApiApiKeys, value: string) {
    this.authentications[TenantinfocontrollerApiApiKeys[key]].apiKey = value;
  }
  /**
   * Creates tenant info in RDS, the tenant info contains the configuration of the tenant, RDS will use this configuration to POST a notification after batch retrieve processing completed to notifyUrl and relevant http headers.
   * @summary Creates tenant info in RDS
   * @param tenantInfoDto tenantInfoDto
   * @param applicationKey
   * @param tenantId
   * @param env
   */
  public createTenantInfo (tenantInfoDto: TenantInfoDTO, applicationKey: string, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: TenantInfoDTO;  }> {
    const localVarPath = this.basePath + '/tenantInfo';
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'tenantInfoDto' is not null or undefined
    if (tenantInfoDto === null || tenantInfoDto === undefined) {
      throw new Error('Required parameter tenantInfoDto was null or undefined when calling createTenantInfo.');
    }

    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling createTenantInfo.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling createTenantInfo.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'POST',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: tenantInfoDto,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: TenantInfoDTO;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Reads the tenant info from RDS, HTTP code 404 will be returned if the tenant has no info in RDS
   * @summary Reads the tenant info from RDS
   * @param applicationKey
   * @param tenantId
   * @param env
   */
  public readTenantInfo (applicationKey: string, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: TenantInfoDTO;  }> {
    const localVarPath = this.basePath + '/tenantInfo';
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling readTenantInfo.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling readTenantInfo.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'GET',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: TenantInfoDTO;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Updates a tenant info by id and TenantInfoDTO
   * @summary Updates tenant info in RDS
   * @param tenantInfoDTO tenantInfoDTO
   * @param applicationKey
   * @param tenantId
   * @param env
   */
  public updateTenantInfo (tenantInfoDTO: TenantInfoDTO, applicationKey: string, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: TenantInfoDTO;  }> {
    const localVarPath = this.basePath + '/tenantInfo';
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'tenantInfoDTO' is not null or undefined
    if (tenantInfoDTO === null || tenantInfoDTO === undefined) {
      throw new Error('Required parameter tenantInfoDTO was null or undefined when calling updateTenantInfo.');
    }

    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling updateTenantInfo.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling updateTenantInfo.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'PUT',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: tenantInfoDTO,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: TenantInfoDTO;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum TransactioncontrollerApiApiKeys {
}

export class TransactioncontrollerApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders : any = {};
  protected _useQuerystring : boolean = false;

  protected authentications = {
    'default': <Authentication>new VoidAuth(),
  }

  constructor(basePath?: string);
  constructor(basePathOrUsername: string, password?: string, basePath?: string) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: TransactioncontrollerApiApiKeys, value: string) {
    this.authentications[TransactioncontrollerApiApiKeys[key]].apiKey = value;
  }
  /**
   * Adds addtional data to an existing Transaction
   * @summary Adds additional data to Transaction
   * @param applicationKey
   * @param additionalData Map of additional data
   * @param transactionId Transaction ID
   * @param tenantId
   * @param env
   */
  public createAdditionalData (applicationKey: string, additionalData: any, transactionId: string, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: TransactionDTO;  }> {
    const localVarPath = this.basePath + '/transactions/{transactionId}/additionalData'
      .replace('{' + 'transactionId' + '}', String(transactionId));
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling createAdditionalData.');
    }

    // verify required parameter 'additionalData' is not null or undefined
    if (additionalData === null || additionalData === undefined) {
      throw new Error('Required parameter additionalData was null or undefined when calling createAdditionalData.');
    }

    // verify required parameter 'transactionId' is not null or undefined
    if (transactionId === null || transactionId === undefined) {
      throw new Error('Required parameter transactionId was null or undefined when calling createAdditionalData.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling createAdditionalData.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'POST',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: additionalData,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: TransactionDTO;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Gets a list of events and add them to an existing Transaction, if the Transaction not exists will return HTTP code 404
   * @summary Creates events for specific transaction
   * @param applicationKey
   * @param events List of events
   * @param transactionId Transaction ID
   * @param tenantId
   * @param env
   */
  public createEvents (applicationKey: string, events: EventDTO, transactionId: string, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: TransactionDTO;  }> {
    const localVarPath = this.basePath + '/transactions/{transactionId}/events'
      .replace('{' + 'transactionId' + '}', String(transactionId));
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling createEvents.');
    }

    // verify required parameter 'events' is not null or undefined
    if (events === null || events === undefined) {
      throw new Error('Required parameter events was null or undefined when calling createEvents.');
    }

    // verify required parameter 'transactionId' is not null or undefined
    if (transactionId === null || transactionId === undefined) {
      throw new Error('Required parameter transactionId was null or undefined when calling createEvents.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling createEvents.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'POST',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: events,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: TransactionDTO;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Gets a list of pages and add them to an existing Transaction, if the Transaction not exists will return HTTP code 404
   * @summary Creates pages for specific transaction
   * @param applicationKey
   * @param pages List of pages
   * @param transactionId Transaction ID
   * @param tenantId
   * @param env
   */
  public createPages (applicationKey: string, pages: PageDTO, transactionId: string, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: TransactionDTO;  }> {
    const localVarPath = this.basePath + '/transactions/{transactionId}/pages'
      .replace('{' + 'transactionId' + '}', String(transactionId));
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling createPages.');
    }

    // verify required parameter 'pages' is not null or undefined
    if (pages === null || pages === undefined) {
      throw new Error('Required parameter pages was null or undefined when calling createPages.');
    }

    // verify required parameter 'transactionId' is not null or undefined
    if (transactionId === null || transactionId === undefined) {
      throw new Error('Required parameter transactionId was null or undefined when calling createPages.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling createPages.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'POST',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: pages,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: TransactionDTO;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Gets a list of varibales and add them to an existing Transaction, if the Transaction not exists will return HTTP code 404
   * @summary Creates variables for specific transaction
   * @param applicationKey
   * @param variables List of variables
   * @param transactionId Transaction ID
   * @param tenantId
   * @param env
   */
  public createVariables (applicationKey: string, variables: VariableDTO, transactionId: string, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: TransactionDTO;  }> {
    const localVarPath = this.basePath + '/transactions/{transactionId}/variables'
      .replace('{' + 'transactionId' + '}', String(transactionId));
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling createVariables.');
    }

    // verify required parameter 'variables' is not null or undefined
    if (variables === null || variables === undefined) {
      throw new Error('Required parameter variables was null or undefined when calling createVariables.');
    }

    // verify required parameter 'transactionId' is not null or undefined
    if (transactionId === null || transactionId === undefined) {
      throw new Error('Required parameter transactionId was null or undefined when calling createVariables.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling createVariables.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'POST',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: variables,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: TransactionDTO;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Gets Transaction by id, if not exists HTTP code 404 returned
   * @summary Reads specific Transaction from RDS
   * @param applicationKey
   * @param transactionId Transaction ID
   * @param tenantId
   * @param env
   */
  public getTransaction (applicationKey: string, transactionId: string, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: TransactionDTO;  }> {
    const localVarPath = this.basePath + '/transactions/{transactionId}'
      .replace('{' + 'transactionId' + '}', String(transactionId));
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling getTransaction.');
    }

    // verify required parameter 'transactionId' is not null or undefined
    if (transactionId === null || transactionId === undefined) {
      throw new Error('Required parameter transactionId was null or undefined when calling getTransaction.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling getTransaction.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'GET',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: TransactionDTO;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Reads results from RDS using the batchId returned from 'Offline read of Transactions' (/rds/batch)
   * @summary Gets the batch retrieve results in a zip file
   * @param applicationKey
   * @param batchId Batch D
   * @param tenantId
   * @param env
   */
  public getTransactionBatchResult (applicationKey: string, batchId: string, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body: Array<string>;  }> {
    const localVarPath = this.basePath + '/transactions/result/{batchId}'
      .replace('{' + 'batchId' + '}', String(batchId));
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling getTransactionBatchResult.');
    }

    // verify required parameter 'batchId' is not null or undefined
    if (batchId === null || batchId === undefined) {
      throw new Error('Required parameter batchId was null or undefined when calling getTransactionBatchResult.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling getTransactionBatchResult.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'GET',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<string>;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Reads Transactions from RDS by time range, customer id or/and externalSystemId, if all the parameters are empty will read all Transactions. In oth cases the maximum results can be retrieved by this API is 1000, if you need to retrieve more please use the batch retrieve API /rds/batch
   * @summary Reads list of Transaction by criteria
   * @param applicationKey
   * @param tenantId
   * @param timeFrom The start time
   * @param timeTo The end time
   * @param customerId Customer ID
   * @param externalSystemId ExternalSystem ID
   * @param source Transaction source
   * @param categoryId Category ID
   * @param variables Variables list to retrieve, if not passed nothing will be retrieved, if pass the keyword &#39;all&#39;, all varibales will be returned
   * @param env
   */
  public getTransactions (applicationKey: string, tenantId: string, timeFrom?: number, timeTo?: number, customerId?: string, externalSystemId?: string, source?: string, categoryId?: string, variables?: ModelObject, env?: string) : Promise<{ response: http.ClientResponse; body: Array<TransactionDTO>;  }> {
    const localVarPath = this.basePath + '/transactions';
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling getTransactions.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling getTransactions.');
    }

    if (timeFrom !== undefined) {
      queryParameters['timeFrom'] = timeFrom;
    }

    if (timeTo !== undefined) {
      queryParameters['timeTo'] = timeTo;
    }

    if (customerId !== undefined) {
      queryParameters['customerId'] = customerId;
    }

    if (externalSystemId !== undefined) {
      queryParameters['externalSystemId'] = externalSystemId;
    }

    if (source !== undefined) {
      queryParameters['source'] = source;
    }

    if (categoryId !== undefined) {
      queryParameters['categoryId'] = categoryId;
    }

    if (variables !== undefined) {
      queryParameters['variables'] = variables;
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'GET',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: Array<TransactionDTO>;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * This API reads Transactions asynchronously, a batchId generated and returned immediatly to the caller as HTTP header, then an async service call to query the Transactions by the time range, customer id or/and externalSystemId executed and stores the results using the batchId generated earlier, this batchId will be used later to get the batch processing results
   * @summary Offline read of Transactions
   * @param applicationKey
   * @param tenantId
   * @param timeFrom The start time
   * @param timeTo The end time
   * @param customerId Customer ID
   * @param externalSystemId ExternalSystem ID
   * @param source Transaction source
   * @param categoryId Category ID
   * @param variables Variables list to retrieve, if not passed nothing will be retrieved, if pass the keyword &#39;all&#39;, all varibales will be returned
   * @param env
   */
  public getTransactionsInBatch (applicationKey: string, tenantId: string, timeFrom?: number, timeTo?: number, customerId?: string, externalSystemId?: string, source?: string, categoryId?: string, variables?: ModelObject, env?: string) : Promise<{ response: http.ClientResponse; body: BatchResponse;  }> {
    const localVarPath = this.basePath + '/transactions/batch';
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling getTransactionsInBatch.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling getTransactionsInBatch.');
    }

    if (timeFrom !== undefined) {
      queryParameters['timeFrom'] = timeFrom;
    }

    if (timeTo !== undefined) {
      queryParameters['timeTo'] = timeTo;
    }

    if (customerId !== undefined) {
      queryParameters['customerId'] = customerId;
    }

    if (externalSystemId !== undefined) {
      queryParameters['externalSystemId'] = externalSystemId;
    }

    if (source !== undefined) {
      queryParameters['source'] = source;
    }

    if (categoryId !== undefined) {
      queryParameters['categoryId'] = categoryId;
    }

    if (variables !== undefined) {
      queryParameters['variables'] = variables;
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'POST',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: BatchResponse;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Gets a list of TransactionDTOs and loads them into RDS, RDS creates Transaction for each DTO in the list
   * @summary Loads list of transactions to RDS
   * @param applicationKey
   * @param transactions List of transactions
   * @param tenantId
   * @param env
   */
  public loadTransactions (applicationKey: string, transactions: TransactionDTO, tenantId: string, env?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
    const localVarPath = this.basePath + '/transactions';
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling loadTransactions.');
    }

    // verify required parameter 'transactions' is not null or undefined
    if (transactions === null || transactions === undefined) {
      throw new Error('Required parameter transactions was null or undefined when calling loadTransactions.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling loadTransactions.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'POST',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: transactions,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Starts a transaction and return an empty TransactionDTO with id to the caller, caller also can send the externalSystemId to be used later to get transactions
   * @summary Starts a transaction in RDS
   * @param applicationKey
   * @param source Transaction source
   * @param tenantId
   * @param externalSystemId External System ID
   * @param env
   */
  public startTransaction (applicationKey: string, source: string, tenantId: string, externalSystemId?: string, env?: string) : Promise<{ response: http.ClientResponse; body: TransactionDTO;  }> {
    const localVarPath = this.basePath + '/transactions/start';
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling startTransaction.');
    }

    // verify required parameter 'source' is not null or undefined
    if (source === null || source === undefined) {
      throw new Error('Required parameter source was null or undefined when calling startTransaction.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling startTransaction.');
    }

    if (externalSystemId !== undefined) {
      queryParameters['externalSystemId'] = externalSystemId;
    }

    if (source !== undefined) {
      queryParameters['source'] = source;
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'POST',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: TransactionDTO;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Updates specific Transaction in RDS using the transaction id and updated TransactionDTO, HTTP code 404 returned if the Transaction not exists
   * @summary Updates specific transaction
   * @param applicationKey
   * @param transactionId Transaction ID
   * @param tenantId
   * @param transactionDto Transaction DTO
   * @param env
   */
  public updateTransaction (applicationKey: string, transactionId: string, tenantId: string, transactionDto?: string, env?: string) : Promise<{ response: http.ClientResponse; body: TransactionDTO;  }> {
    const localVarPath = this.basePath + '/transactions/{transactionId}'
      .replace('{' + 'transactionId' + '}', String(transactionId));
    let queryParameters: any = {};
    let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
    let formParams: any = {};


    // verify required parameter 'applicationKey' is not null or undefined
    if (applicationKey === null || applicationKey === undefined) {
      throw new Error('Required parameter applicationKey was null or undefined when calling updateTransaction.');
    }

    // verify required parameter 'transactionId' is not null or undefined
    if (transactionId === null || transactionId === undefined) {
      throw new Error('Required parameter transactionId was null or undefined when calling updateTransaction.');
    }

    // verify required parameter 'tenantId' is not null or undefined
    if (tenantId === null || tenantId === undefined) {
      throw new Error('Required parameter tenantId was null or undefined when calling updateTransaction.');
    }

    headerParams['Application-Key'] = applicationKey;

    headerParams['Tenant-Id'] = tenantId;

    headerParams['Env'] = env;

    let useFormData = false;

    let requestOptions: request.Options = {
      method: 'PUT',
      qs: queryParameters,
      headers: headerParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: transactionDto,
    };

    this.authentications.default.applyToRequest(requestOptions);

    if (Object.keys(formParams).length) {
      if (useFormData) {
        (<any>requestOptions).formData = formParams;
      } else {
        requestOptions.form = formParams;
      }
    }
    return new Promise<{ response: http.ClientResponse; body: TransactionDTO;  }>((resolve, reject) => {
      request(requestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
