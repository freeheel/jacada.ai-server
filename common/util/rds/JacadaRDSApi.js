"use strict";
/**
 * Raw Data Service API
 * Raw data service (aka rds) API's documentation
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var request = require("request");
var Promise = require("bluebird");
var defaultBasePath = 'https://gointeract.io/rds';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
/* tslint:disable:no-unused-variable */
var AggregationCreateResponse = (function () {
    function AggregationCreateResponse() {
    }
    return AggregationCreateResponse;
}());
exports.AggregationCreateResponse = AggregationCreateResponse;
var AggregationDTO = (function () {
    function AggregationDTO() {
    }
    return AggregationDTO;
}());
exports.AggregationDTO = AggregationDTO;
var AggregationResponse = (function () {
    function AggregationResponse() {
    }
    return AggregationResponse;
}());
exports.AggregationResponse = AggregationResponse;
var BatchResponse = (function () {
    function BatchResponse() {
    }
    return BatchResponse;
}());
exports.BatchResponse = BatchResponse;
var CustomerDTO = (function () {
    function CustomerDTO() {
    }
    return CustomerDTO;
}());
exports.CustomerDTO = CustomerDTO;
var EventDTO = (function () {
    function EventDTO() {
    }
    return EventDTO;
}());
exports.EventDTO = EventDTO;
var FieldDTO = (function () {
    function FieldDTO() {
    }
    return FieldDTO;
}());
exports.FieldDTO = FieldDTO;
var PageDTO = (function () {
    function PageDTO() {
    }
    return PageDTO;
}());
exports.PageDTO = PageDTO;
var QueryFieldsDTO = (function () {
    function QueryFieldsDTO() {
    }
    return QueryFieldsDTO;
}());
exports.QueryFieldsDTO = QueryFieldsDTO;
var TenantInfoDTO = (function () {
    function TenantInfoDTO() {
    }
    return TenantInfoDTO;
}());
exports.TenantInfoDTO = TenantInfoDTO;
var TransactionDTO = (function () {
    function TransactionDTO() {
    }
    return TransactionDTO;
}());
exports.TransactionDTO = TransactionDTO;
var Variable = (function () {
    function Variable() {
    }
    return Variable;
}());
exports.Variable = Variable;
var VariableDTO = (function () {
    function VariableDTO() {
    }
    return VariableDTO;
}());
exports.VariableDTO = VariableDTO;
var VariableValue = (function () {
    function VariableValue() {
    }
    return VariableValue;
}());
exports.VariableValue = VariableValue;
var HttpBasicAuth = (function () {
    function HttpBasicAuth() {
    }
    HttpBasicAuth.prototype.applyToRequest = function (requestOptions) {
        requestOptions.auth = {
            username: this.username, password: this.password
        };
    };
    return HttpBasicAuth;
}());
exports.HttpBasicAuth = HttpBasicAuth;
var ApiKeyAuth = (function () {
    function ApiKeyAuth(location, paramName) {
        this.location = location;
        this.paramName = paramName;
    }
    ApiKeyAuth.prototype.applyToRequest = function (requestOptions) {
        if (this.location == "query") {
            requestOptions.qs[this.paramName] = this.apiKey;
        }
        else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    };
    return ApiKeyAuth;
}());
exports.ApiKeyAuth = ApiKeyAuth;
var OAuth = (function () {
    function OAuth() {
    }
    OAuth.prototype.applyToRequest = function (requestOptions) {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    };
    return OAuth;
}());
exports.OAuth = OAuth;
var VoidAuth = (function () {
    function VoidAuth() {
    }
    VoidAuth.prototype.applyToRequest = function (_) {
        // Do nothing
    };
    return VoidAuth;
}());
exports.VoidAuth = VoidAuth;
var AggregationcontrollerApiApiKeys;
(function (AggregationcontrollerApiApiKeys) {
})(AggregationcontrollerApiApiKeys = exports.AggregationcontrollerApiApiKeys || (exports.AggregationcontrollerApiApiKeys = {}));
var AggregationcontrollerApi = (function () {
    function AggregationcontrollerApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(AggregationcontrollerApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AggregationcontrollerApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    AggregationcontrollerApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    AggregationcontrollerApi.prototype.setApiKey = function (key, value) {
        this.authentications[AggregationcontrollerApiApiKeys[key]].apiKey = value;
    };
    /**
     * Aggregates raw data by given query.   If the query is invalid HTTP code 406 is returned
     * @summary Aggregates raw data
     * @param applicationKey RDS application key
     * @param aggregationDTO AggregationDTO includes the Aggregation query.   The aggregation query json must be escaped.   See https://www.freeformatter.com/json-escape.html for online json escaping  Illegal keywords: &#39;$where&#39;, &#39;$lookup&#39;, &#39;$out&#39;, &#39;$collStats&#39;, &#39;$indexStats&#39;, &#39;startTimestamp&#39; and &#39;endTimestamp&#39; in $match stage
     * @param tenantId Tenant Id
     * @param env Tenant environment name (Interact multi-emvironment)
     */
    AggregationcontrollerApi.prototype.aggregate = function (applicationKey, aggregationDTO, tenantId, env) {
        var localVarPath = this.basePath + '/aggregation';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling aggregate.');
        }
        // verify required parameter 'aggregationDTO' is not null or undefined
        if (aggregationDTO === null || aggregationDTO === undefined) {
            throw new Error('Required parameter aggregationDTO was null or undefined when calling aggregate.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling aggregate.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: aggregationDTO,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Returns aggregated data by given query.   If the query is invalid HTTP code 406 is returned
     * @summary Retrieves aggregated data
     * @param applicationKey RDS application key
     * @param query Aggregation query.  The aggregation query json must be escaped.   See https://www.freeformatter.com/json-escape.html for online json escaping  Illegal keywords: &#39;$where&#39;, &#39;$lookup&#39;, &#39;$out&#39;, &#39;$collStats&#39;, &#39;$indexStats&#39;
     * @param aggregationId Aggregation definition id
     * @param tenantId Tenant Id
     * @param env Tenant environment name (Interact multi-emvironment)
     */
    AggregationcontrollerApi.prototype.aggregationRetrieve = function (applicationKey, query, aggregationId, tenantId, env) {
        var localVarPath = this.basePath + '/aggregation/results/{aggregationId}'
            .replace('{' + 'aggregationId' + '}', String(aggregationId));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling aggregationRetrieve.');
        }
        // verify required parameter 'query' is not null or undefined
        if (query === null || query === undefined) {
            throw new Error('Required parameter query was null or undefined when calling aggregationRetrieve.');
        }
        // verify required parameter 'aggregationId' is not null or undefined
        if (aggregationId === null || aggregationId === undefined) {
            throw new Error('Required parameter aggregationId was null or undefined when calling aggregationRetrieve.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling aggregationRetrieve.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: query,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * For testing the aggregation query before calling the aggregate API.  Will run the query on the past 4 hours and will return the results of the aggregation.  If the query is invalid HTTP code 406 is returned
     * @summary Tests aggregation query of raw data
     * @param applicationKey RDS application key
     * @param query Aggregation test query.  The aggregation query json must be escaped.   See https://www.freeformatter.com/json-escape.html for online json escaping  Illegal keywords: &#39;$where&#39;, &#39;$lookup&#39;, &#39;$out&#39;, &#39;$collStats&#39;, &#39;$indexStats&#39;, &#39;startTimestamp&#39; and &#39;endTimestamp&#39; in $match stage
     * @param tenantId Tenant Id
     * @param env Tenant environment name (Interact multi-emvironment)
     */
    AggregationcontrollerApi.prototype.aggregationTest = function (applicationKey, query, tenantId, env) {
        var localVarPath = this.basePath + '/aggregation/test';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling aggregationTest.');
        }
        // verify required parameter 'query' is not null or undefined
        if (query === null || query === undefined) {
            throw new Error('Required parameter query was null or undefined when calling aggregationTest.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling aggregationTest.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: query,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Deletes aggregation by id, if the the aggregation not exists HTTP code 404 returned
     * @summary Deletes a specific aggregation in RDS
     * @param applicationKey
     * @param aggregationId The aggregation ID
     * @param tenantId
     * @param env
     */
    AggregationcontrollerApi.prototype.deleteAggregation = function (applicationKey, aggregationId, tenantId, env) {
        var localVarPath = this.basePath + '/aggregation/{aggregationId}'
            .replace('{' + 'aggregationId' + '}', String(aggregationId));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling deleteAggregation.');
        }
        // verify required parameter 'aggregationId' is not null or undefined
        if (aggregationId === null || aggregationId === undefined) {
            throw new Error('Required parameter aggregationId was null or undefined when calling deleteAggregation.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling deleteAggregation.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Returns aggregated data by given query.
     * @summary Retrieves aggregated data by find query
     * @param applicationKey RDS application key
     * @param queryFieldsDTO Fields to use in the find query.
     * @param aggregationId Aggregation definition id
     * @param tenantId Tenant Id
     * @param env Tenant environment name (Interact multi-emvironment)
     */
    AggregationcontrollerApi.prototype.findQueryRetrieve = function (applicationKey, queryFieldsDTO, aggregationId, tenantId, env) {
        var localVarPath = this.basePath + '/aggregation/results/simple/{aggregationId}'
            .replace('{' + 'aggregationId' + '}', String(aggregationId));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling findQueryRetrieve.');
        }
        // verify required parameter 'queryFieldsDTO' is not null or undefined
        if (queryFieldsDTO === null || queryFieldsDTO === undefined) {
            throw new Error('Required parameter queryFieldsDTO was null or undefined when calling findQueryRetrieve.');
        }
        // verify required parameter 'aggregationId' is not null or undefined
        if (aggregationId === null || aggregationId === undefined) {
            throw new Error('Required parameter aggregationId was null or undefined when calling findQueryRetrieve.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling findQueryRetrieve.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: queryFieldsDTO,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Get list of aggregations created for tenant
     * @summary Gets list of aggregations
     * @param applicationKey
     * @param tenantId
     * @param env
     */
    AggregationcontrollerApi.prototype.getAggregations = function (applicationKey, tenantId, env) {
        var localVarPath = this.basePath + '/aggregation';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling getAggregations.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling getAggregations.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Updates aggregation by id, if the the aggregation not exists HTTP code 404 returned
     * @summary Updates a specific aggregation in RDS
     * @param applicationKey
     * @param aggregationId The aggregation ID
     * @param aggregationDTO AggregationDTO includes the Aggregation query.   The aggregation query json must be escaped.   See https://www.freeformatter.com/json-escape.html for online json escaping  Illegal keywords: &#39;$where&#39;, &#39;$lookup&#39;, &#39;$out&#39;, &#39;$collStats&#39;, &#39;$indexStats&#39;, &#39;startTimestamp&#39; and &#39;endTimestamp&#39; in $match stage
     * @param tenantId
     * @param env
     */
    AggregationcontrollerApi.prototype.updateAggregation = function (applicationKey, aggregationId, aggregationDTO, tenantId, env) {
        var localVarPath = this.basePath + '/aggregation/{aggregationId}'
            .replace('{' + 'aggregationId' + '}', String(aggregationId));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling updateAggregation.');
        }
        // verify required parameter 'aggregationId' is not null or undefined
        if (aggregationId === null || aggregationId === undefined) {
            throw new Error('Required parameter aggregationId was null or undefined when calling updateAggregation.');
        }
        // verify required parameter 'aggregationDTO' is not null or undefined
        if (aggregationDTO === null || aggregationDTO === undefined) {
            throw new Error('Required parameter aggregationDTO was null or undefined when calling updateAggregation.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling updateAggregation.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: aggregationDTO,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return AggregationcontrollerApi;
}());
exports.AggregationcontrollerApi = AggregationcontrollerApi;
var CustomercontrollerApiApiKeys;
(function (CustomercontrollerApiApiKeys) {
})(CustomercontrollerApiApiKeys = exports.CustomercontrollerApiApiKeys || (exports.CustomercontrollerApiApiKeys = {}));
var CustomercontrollerApi = (function () {
    function CustomercontrollerApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(CustomercontrollerApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CustomercontrollerApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    CustomercontrollerApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    CustomercontrollerApi.prototype.setApiKey = function (key, value) {
        this.authentications[CustomercontrollerApiApiKeys[key]].apiKey = value;
    };
    /**
     * Creates the customer in RDS from the CustomerDTO in the body and return HTTP code 201 (created)
     * @summary Creates customer in RDS
     * @param applicationKey
     * @param customerDto The customer body
     * @param tenantId
     * @param env
     */
    CustomercontrollerApi.prototype.createCustomer = function (applicationKey, customerDto, tenantId, env) {
        var localVarPath = this.basePath + '/customers';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling createCustomer.');
        }
        // verify required parameter 'customerDto' is not null or undefined
        if (customerDto === null || customerDto === undefined) {
            throw new Error('Required parameter customerDto was null or undefined when calling createCustomer.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling createCustomer.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: customerDto,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Deletes customer by id, if the the customer not exists HTTP code 404 returned
     * @summary Deletes a customer in RDS
     * @param applicationKey
     * @param customerId The customer ID
     * @param tenantId
     * @param env
     */
    CustomercontrollerApi.prototype.deleteCustomer = function (applicationKey, customerId, tenantId, env) {
        var localVarPath = this.basePath + '/customers/{customerId}'
            .replace('{' + 'customerId' + '}', String(customerId));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling deleteCustomer.');
        }
        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling deleteCustomer.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling deleteCustomer.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Reads the customer from RDS by customer id, if the customer not exists in RDS, HTTP error 404 returned
     * @summary Gets specific customer from RDS by customer id
     * @param applicationKey
     * @param customerId The customer ID
     * @param tenantId
     * @param env
     */
    CustomercontrollerApi.prototype.readCustomer = function (applicationKey, customerId, tenantId, env) {
        var localVarPath = this.basePath + '/customers/{customerId}'
            .replace('{' + 'customerId' + '}', String(customerId));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling readCustomer.');
        }
        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling readCustomer.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling readCustomer.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Using customer id and CustomerDTO will update the spcific customer and return HTTP code 200 if success or if the customer not found HTTP code 404
     * @summary Updates customer in RDS
     * @param applicationKey
     * @param customerDto The customer body
     * @param customerId The customer ID
     * @param tenantId
     * @param env
     */
    CustomercontrollerApi.prototype.updateCustomer = function (applicationKey, customerDto, customerId, tenantId, env) {
        var localVarPath = this.basePath + '/customers/{customerId}'
            .replace('{' + 'customerId' + '}', String(customerId));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling updateCustomer.');
        }
        // verify required parameter 'customerDto' is not null or undefined
        if (customerDto === null || customerDto === undefined) {
            throw new Error('Required parameter customerDto was null or undefined when calling updateCustomer.');
        }
        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling updateCustomer.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling updateCustomer.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: customerDto,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return CustomercontrollerApi;
}());
exports.CustomercontrollerApi = CustomercontrollerApi;
var TenantinfocontrollerApiApiKeys;
(function (TenantinfocontrollerApiApiKeys) {
})(TenantinfocontrollerApiApiKeys = exports.TenantinfocontrollerApiApiKeys || (exports.TenantinfocontrollerApiApiKeys = {}));
var TenantinfocontrollerApi = (function () {
    function TenantinfocontrollerApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(TenantinfocontrollerApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TenantinfocontrollerApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    TenantinfocontrollerApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    TenantinfocontrollerApi.prototype.setApiKey = function (key, value) {
        this.authentications[TenantinfocontrollerApiApiKeys[key]].apiKey = value;
    };
    /**
     * Creates tenant info in RDS, the tenant info contains the configuration of the tenant, RDS will use this configuration to POST a notification after batch retrieve processing completed to notifyUrl and relevant http headers.
     * @summary Creates tenant info in RDS
     * @param tenantInfoDto tenantInfoDto
     * @param applicationKey
     * @param tenantId
     * @param env
     */
    TenantinfocontrollerApi.prototype.createTenantInfo = function (tenantInfoDto, applicationKey, tenantId, env) {
        var localVarPath = this.basePath + '/tenantInfo';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'tenantInfoDto' is not null or undefined
        if (tenantInfoDto === null || tenantInfoDto === undefined) {
            throw new Error('Required parameter tenantInfoDto was null or undefined when calling createTenantInfo.');
        }
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling createTenantInfo.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling createTenantInfo.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: tenantInfoDto,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Reads the tenant info from RDS, HTTP code 404 will be returned if the tenant has no info in RDS
     * @summary Reads the tenant info from RDS
     * @param applicationKey
     * @param tenantId
     * @param env
     */
    TenantinfocontrollerApi.prototype.readTenantInfo = function (applicationKey, tenantId, env) {
        var localVarPath = this.basePath + '/tenantInfo';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling readTenantInfo.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling readTenantInfo.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Updates a tenant info by id and TenantInfoDTO
     * @summary Updates tenant info in RDS
     * @param tenantInfoDTO tenantInfoDTO
     * @param applicationKey
     * @param tenantId
     * @param env
     */
    TenantinfocontrollerApi.prototype.updateTenantInfo = function (tenantInfoDTO, applicationKey, tenantId, env) {
        var localVarPath = this.basePath + '/tenantInfo';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'tenantInfoDTO' is not null or undefined
        if (tenantInfoDTO === null || tenantInfoDTO === undefined) {
            throw new Error('Required parameter tenantInfoDTO was null or undefined when calling updateTenantInfo.');
        }
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling updateTenantInfo.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling updateTenantInfo.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: tenantInfoDTO,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return TenantinfocontrollerApi;
}());
exports.TenantinfocontrollerApi = TenantinfocontrollerApi;
var TransactioncontrollerApiApiKeys;
(function (TransactioncontrollerApiApiKeys) {
})(TransactioncontrollerApiApiKeys = exports.TransactioncontrollerApiApiKeys || (exports.TransactioncontrollerApiApiKeys = {}));
var TransactioncontrollerApi = (function () {
    function TransactioncontrollerApi(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    Object.defineProperty(TransactioncontrollerApi.prototype, "useQuerystring", {
        set: function (value) {
            this._useQuerystring = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TransactioncontrollerApi.prototype, "basePath", {
        get: function () {
            return this._basePath;
        },
        set: function (basePath) {
            this._basePath = basePath;
        },
        enumerable: true,
        configurable: true
    });
    TransactioncontrollerApi.prototype.setDefaultAuthentication = function (auth) {
        this.authentications.default = auth;
    };
    TransactioncontrollerApi.prototype.setApiKey = function (key, value) {
        this.authentications[TransactioncontrollerApiApiKeys[key]].apiKey = value;
    };
    /**
     * Adds addtional data to an existing Transaction
     * @summary Adds additional data to Transaction
     * @param applicationKey
     * @param additionalData Map of additional data
     * @param transactionId Transaction ID
     * @param tenantId
     * @param env
     */
    TransactioncontrollerApi.prototype.createAdditionalData = function (applicationKey, additionalData, transactionId, tenantId, env) {
        var localVarPath = this.basePath + '/transactions/{transactionId}/additionalData'
            .replace('{' + 'transactionId' + '}', String(transactionId));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling createAdditionalData.');
        }
        // verify required parameter 'additionalData' is not null or undefined
        if (additionalData === null || additionalData === undefined) {
            throw new Error('Required parameter additionalData was null or undefined when calling createAdditionalData.');
        }
        // verify required parameter 'transactionId' is not null or undefined
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling createAdditionalData.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling createAdditionalData.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: additionalData,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Gets a list of events and add them to an existing Transaction, if the Transaction not exists will return HTTP code 404
     * @summary Creates events for specific transaction
     * @param applicationKey
     * @param events List of events
     * @param transactionId Transaction ID
     * @param tenantId
     * @param env
     */
    TransactioncontrollerApi.prototype.createEvents = function (applicationKey, events, transactionId, tenantId, env) {
        var localVarPath = this.basePath + '/transactions/{transactionId}/events'
            .replace('{' + 'transactionId' + '}', String(transactionId));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling createEvents.');
        }
        // verify required parameter 'events' is not null or undefined
        if (events === null || events === undefined) {
            throw new Error('Required parameter events was null or undefined when calling createEvents.');
        }
        // verify required parameter 'transactionId' is not null or undefined
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling createEvents.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling createEvents.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: events,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Gets a list of pages and add them to an existing Transaction, if the Transaction not exists will return HTTP code 404
     * @summary Creates pages for specific transaction
     * @param applicationKey
     * @param pages List of pages
     * @param transactionId Transaction ID
     * @param tenantId
     * @param env
     */
    TransactioncontrollerApi.prototype.createPages = function (applicationKey, pages, transactionId, tenantId, env) {
        var localVarPath = this.basePath + '/transactions/{transactionId}/pages'
            .replace('{' + 'transactionId' + '}', String(transactionId));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling createPages.');
        }
        // verify required parameter 'pages' is not null or undefined
        if (pages === null || pages === undefined) {
            throw new Error('Required parameter pages was null or undefined when calling createPages.');
        }
        // verify required parameter 'transactionId' is not null or undefined
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling createPages.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling createPages.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: pages,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Gets a list of varibales and add them to an existing Transaction, if the Transaction not exists will return HTTP code 404
     * @summary Creates variables for specific transaction
     * @param applicationKey
     * @param variables List of variables
     * @param transactionId Transaction ID
     * @param tenantId
     * @param env
     */
    TransactioncontrollerApi.prototype.createVariables = function (applicationKey, variables, transactionId, tenantId, env) {
        var localVarPath = this.basePath + '/transactions/{transactionId}/variables'
            .replace('{' + 'transactionId' + '}', String(transactionId));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling createVariables.');
        }
        // verify required parameter 'variables' is not null or undefined
        if (variables === null || variables === undefined) {
            throw new Error('Required parameter variables was null or undefined when calling createVariables.');
        }
        // verify required parameter 'transactionId' is not null or undefined
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling createVariables.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling createVariables.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: variables,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Gets Transaction by id, if not exists HTTP code 404 returned
     * @summary Reads specific Transaction from RDS
     * @param applicationKey
     * @param transactionId Transaction ID
     * @param tenantId
     * @param env
     */
    TransactioncontrollerApi.prototype.getTransaction = function (applicationKey, transactionId, tenantId, env) {
        var localVarPath = this.basePath + '/transactions/{transactionId}'
            .replace('{' + 'transactionId' + '}', String(transactionId));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling getTransaction.');
        }
        // verify required parameter 'transactionId' is not null or undefined
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling getTransaction.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling getTransaction.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Reads results from RDS using the batchId returned from 'Offline read of Transactions' (/rds/batch)
     * @summary Gets the batch retrieve results in a zip file
     * @param applicationKey
     * @param batchId Batch D
     * @param tenantId
     * @param env
     */
    TransactioncontrollerApi.prototype.getTransactionBatchResult = function (applicationKey, batchId, tenantId, env) {
        var localVarPath = this.basePath + '/transactions/result/{batchId}'
            .replace('{' + 'batchId' + '}', String(batchId));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling getTransactionBatchResult.');
        }
        // verify required parameter 'batchId' is not null or undefined
        if (batchId === null || batchId === undefined) {
            throw new Error('Required parameter batchId was null or undefined when calling getTransactionBatchResult.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling getTransactionBatchResult.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Reads Transactions from RDS by time range, customer id or/and externalSystemId, if all the parameters are empty will read all Transactions. In oth cases the maximum results can be retrieved by this API is 1000, if you need to retrieve more please use the batch retrieve API /rds/batch
     * @summary Reads list of Transaction by criteria
     * @param applicationKey
     * @param tenantId
     * @param timeFrom The start time
     * @param timeTo The end time
     * @param customerId Customer ID
     * @param externalSystemId ExternalSystem ID
     * @param source Transaction source
     * @param categoryId Category ID
     * @param variables Variables list to retrieve, if not passed nothing will be retrieved, if pass the keyword &#39;all&#39;, all varibales will be returned
     * @param env
     */
    TransactioncontrollerApi.prototype.getTransactions = function (applicationKey, tenantId, timeFrom, timeTo, customerId, externalSystemId, source, categoryId, variables, env) {
        var localVarPath = this.basePath + '/transactions';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling getTransactions.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling getTransactions.');
        }
        if (timeFrom !== undefined) {
            queryParameters['timeFrom'] = timeFrom;
        }
        if (timeTo !== undefined) {
            queryParameters['timeTo'] = timeTo;
        }
        if (customerId !== undefined) {
            queryParameters['customerId'] = customerId;
        }
        if (externalSystemId !== undefined) {
            queryParameters['externalSystemId'] = externalSystemId;
        }
        if (source !== undefined) {
            queryParameters['source'] = source;
        }
        if (categoryId !== undefined) {
            queryParameters['categoryId'] = categoryId;
        }
        if (variables !== undefined) {
            queryParameters['variables'] = variables;
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * This API reads Transactions asynchronously, a batchId generated and returned immediatly to the caller as HTTP header, then an async service call to query the Transactions by the time range, customer id or/and externalSystemId executed and stores the results using the batchId generated earlier, this batchId will be used later to get the batch processing results
     * @summary Offline read of Transactions
     * @param applicationKey
     * @param tenantId
     * @param timeFrom The start time
     * @param timeTo The end time
     * @param customerId Customer ID
     * @param externalSystemId ExternalSystem ID
     * @param source Transaction source
     * @param categoryId Category ID
     * @param variables Variables list to retrieve, if not passed nothing will be retrieved, if pass the keyword &#39;all&#39;, all varibales will be returned
     * @param env
     */
    TransactioncontrollerApi.prototype.getTransactionsInBatch = function (applicationKey, tenantId, timeFrom, timeTo, customerId, externalSystemId, source, categoryId, variables, env) {
        var localVarPath = this.basePath + '/transactions/batch';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling getTransactionsInBatch.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling getTransactionsInBatch.');
        }
        if (timeFrom !== undefined) {
            queryParameters['timeFrom'] = timeFrom;
        }
        if (timeTo !== undefined) {
            queryParameters['timeTo'] = timeTo;
        }
        if (customerId !== undefined) {
            queryParameters['customerId'] = customerId;
        }
        if (externalSystemId !== undefined) {
            queryParameters['externalSystemId'] = externalSystemId;
        }
        if (source !== undefined) {
            queryParameters['source'] = source;
        }
        if (categoryId !== undefined) {
            queryParameters['categoryId'] = categoryId;
        }
        if (variables !== undefined) {
            queryParameters['variables'] = variables;
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Gets a list of TransactionDTOs and loads them into RDS, RDS creates Transaction for each DTO in the list
     * @summary Loads list of transactions to RDS
     * @param applicationKey
     * @param transactions List of transactions
     * @param tenantId
     * @param env
     */
    TransactioncontrollerApi.prototype.loadTransactions = function (applicationKey, transactions, tenantId, env) {
        var localVarPath = this.basePath + '/transactions';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling loadTransactions.');
        }
        // verify required parameter 'transactions' is not null or undefined
        if (transactions === null || transactions === undefined) {
            throw new Error('Required parameter transactions was null or undefined when calling loadTransactions.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling loadTransactions.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: transactions,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Starts a transaction and return an empty TransactionDTO with id to the caller, caller also can send the externalSystemId to be used later to get transactions
     * @summary Starts a transaction in RDS
     * @param applicationKey
     * @param source Transaction source
     * @param tenantId
     * @param externalSystemId External System ID
     * @param env
     */
    TransactioncontrollerApi.prototype.startTransaction = function (applicationKey, source, tenantId, externalSystemId, env) {
        var localVarPath = this.basePath + '/transactions/start';
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling startTransaction.');
        }
        // verify required parameter 'source' is not null or undefined
        if (source === null || source === undefined) {
            throw new Error('Required parameter source was null or undefined when calling startTransaction.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling startTransaction.');
        }
        if (externalSystemId !== undefined) {
            queryParameters['externalSystemId'] = externalSystemId;
        }
        if (source !== undefined) {
            queryParameters['source'] = source;
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    /**
     * Updates specific Transaction in RDS using the transaction id and updated TransactionDTO, HTTP code 404 returned if the Transaction not exists
     * @summary Updates specific transaction
     * @param applicationKey
     * @param transactionId Transaction ID
     * @param tenantId
     * @param transactionDto Transaction DTO
     * @param env
     */
    TransactioncontrollerApi.prototype.updateTransaction = function (applicationKey, transactionId, tenantId, transactionDto, env) {
        var localVarPath = this.basePath + '/transactions/{transactionId}'
            .replace('{' + 'transactionId' + '}', String(transactionId));
        var queryParameters = {};
        var headerParams = Object.assign({}, this.defaultHeaders);
        var formParams = {};
        // verify required parameter 'applicationKey' is not null or undefined
        if (applicationKey === null || applicationKey === undefined) {
            throw new Error('Required parameter applicationKey was null or undefined when calling updateTransaction.');
        }
        // verify required parameter 'transactionId' is not null or undefined
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling updateTransaction.');
        }
        // verify required parameter 'tenantId' is not null or undefined
        if (tenantId === null || tenantId === undefined) {
            throw new Error('Required parameter tenantId was null or undefined when calling updateTransaction.');
        }
        headerParams['Application-Key'] = applicationKey;
        headerParams['Tenant-Id'] = tenantId;
        headerParams['Env'] = env;
        var useFormData = false;
        var requestOptions = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: transactionDto,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise(function (resolve, reject) {
            request(requestOptions, function (error, response, body) {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    };
    return TransactioncontrollerApi;
}());
exports.TransactioncontrollerApi = TransactioncontrollerApi;
